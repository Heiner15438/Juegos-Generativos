<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>AI Platformer Game Mejorado</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React y ReactDOM -->
    <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- Babel para transpilar JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tone.js para efectos de sonido -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        body {
            background-color: #0f172a; /* bg-slate-900 */
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        .font-pixel {
            font-family: 'Press Start 2P', 'Courier New', monospace;
        }
        /* Controles táctiles */
        .touch-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 30px;
            z-index: 100;
            pointer-events: none; /* El contenedor no bloquea clics */
        }
        .touch-btn {
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: white;
            user-select: none;
            pointer-events: auto; /* Los botones sí son interactivos */
            transition: background-color 0.1s;
        }
        .touch-btn:active {
            background-color: rgba(255, 255, 255, 0.5);
        }
    </style>
</head>

<body>
    <div id="root"></div>

<script type="text/babel">
// --- LÓGICA DEL JUEGO Y SIMULACIÓN DE API ---

const createFallbackLevel = (theme, level) => {
    const difficulty = Math.min(level, 10);
    const platforms = [{ x: 50, y: 450, width: 150, height: 20, type: 'normal' }];
    const platformCount = 15 + difficulty * 3;
    let lastX = 200;

    for (let i = 1; i < platformCount; i++) {
        const gap = 90 + Math.random() * 70;
        const x = lastX + gap;
        const yVariation = Math.sin(i * 0.3) * 120 + Math.cos(i * 0.7) * 80;
        const y = 400 + yVariation;
        const types = ['normal', 'moving', 'bouncy', 'disappearing', 'ice'];
        let type = types[Math.floor(Math.random() * types.length)];
        
        platforms.push({
            x: x,
            y: Math.max(100, Math.min(550, y)),
            width: 70 + Math.random() * 50,
            height: 20,
            type,
            movementRange: type === 'moving' ? 60 + Math.random() * 50 : undefined,
            movementSpeed: type === 'moving' ? 0.5 + difficulty * 0.1 : undefined,
            movementDirection: type === 'moving' ? (Math.random() > 0.5 ? 'horizontal' : 'vertical') : undefined
        });
        lastX = x;
    }

    const enemies = Array.from({ length: 2 + difficulty }, (_, i) => ({
        x: 300 + i * 250 + Math.random() * 100,
        y: Math.random() > 0.5 ? 200 + Math.random() * 200 : 400,
        type: ['walker', 'flyer', 'jumper'][Math.floor(Math.random() * 3)],
        patrolRange: 80 + Math.random() * 40,
        speed: 0.5 + difficulty * 0.15
    }));

    const collectibles = Array.from({ length: 10 + difficulty * 2 }, (_, i) => ({
        x: 150 + i * 150 + Math.random() * 60,
        y: 200 + Math.random() * 250,
        type: Math.random() > 0.85 ? 'powerup' : 'gem',
        value: Math.random() > 0.9 ? 50 : 10
    }));

    const obstacles = Array.from({ length: 3 + Math.floor(difficulty / 2) }, (_, i) => ({
        x: 400 + i * 300 + Math.random() * 100,
        y: 435,
        type: 'spike',
        width: 30 + Math.random() * 20,
        height: 15
    }));

    platforms.push({ x: lastX + 250, y: 450, width: 100, height: 20, type: 'exit' });

    return {
        platforms, enemies, collectibles, obstacles,
        theme: {
            backgroundColor: '#1a1a2e',
            platformColor: '#6c5ce7',
            iceColor: '#74b9ff',
            bouncyColor: '#fab1a0',
            disappearingColor: 'rgba(108, 92, 231, 0.5)',
            exitColor: '#55efc4',
            playerColor: '#a29bfe',
            enemyColor: '#ff7675',
            spikeColor: '#dfe6e9',
            gemColor: '#fdcb6e',
            powerupColor: '#00b894'
        },
        levelName: `Fallback: ${theme} - Nivel ${level}`,
        levelDescription: `Navega por el desafiante mundo de ${theme.toLowerCase()}`,
        levelLength: lastX + 350
    };
};

// Simulación de la API de IA
window.aiAPI = {
    complete: async (prompt) => {
        console.log("--- LLAMADA A LA API SIMULADA ---", prompt);
        await new Promise(resolve => setTimeout(resolve, 1500));
        const themeMatch = prompt.match(/theme "([^"]+)"/);
        const theme = themeMatch ? themeMatch[1] : 'Mundo Misterioso';
        const levelMatch = prompt.match(/level (\d+)/);
        const level = levelMatch ? parseInt(levelMatch[1], 10) : 1;
        const fallbackData = createFallbackLevel(theme, level);
        return JSON.stringify(fallbackData);
    }
};

// --- COMPONENTE PRINCIPAL DE REACT ---
const { useState, useEffect, useRef, useCallback } = React;

// --- Constantes del Juego ---
const GRAVITY = 0.6;
const JUMP_FORCE = -14;
const MOVE_SPEED = 5;
const PLAYER_WIDTH = 28;
const PLAYER_HEIGHT = 36;
const ENEMY_BOUNCE_FORCE = -8;

const PlatformerGame = () => {
    const canvasRef = useRef(null);
    const animationRef = useRef(null);
    const [gameState, setGameState] = useState('menu'); // menu, themeSelect, generating, playing, levelComplete, gameOver
    const [theme, setTheme] = useState('');
    const [customTheme, setCustomTheme] = useState('');
    const [level, setLevel] = useState(1);
    const [score, setScore] = useState(0);
    const [lives, setLives] = useState(3);
    const [isGenerating, setIsGenerating] = useState(false);
    const [levelData, setLevelData] = useState(null);
    
    // --- Referencias de estado del juego para evitar re-renders en el loop ---
    const gameRefs = useRef({
        player: { x: 100, y: 300, vx: 0, vy: 0, width: PLAYER_WIDTH, height: PLAYER_HEIGHT, grounded: false, invincible: 0 },
        camera: { x: 0, y: 0 },
        keys: {},
        platformStates: new Map(),
        enemyStates: new Map(),
        collectibleStates: new Map(),
        particles: [],
        time: 0
    });

    // --- Efectos de Sonido con Tone.js ---
    const sounds = useRef(null);
    useEffect(() => {
        sounds.current = {
            jump: new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination(),
            collectGem: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination(),
            hit: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination(),
            enemyStomp: new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 5, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination(),
            levelComplete: new Tone.PolySynth(Tone.Synth, { oscillator: { type: "fatsawtooth" }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 1 } }).toDestination()
        };
    }, []);

    const playSound = (sound, note, duration = '8n') => {
        if (sounds.current && sounds.current[sound]) {
            sounds.current[sound].triggerAttackRelease(note, duration);
        }
    };

    // --- Generación de Niveles ---
    const generateLevel = useCallback(async () => {
        setIsGenerating(true);
        setGameState('generating');
        const selectedTheme = theme === 'custom' ? customTheme : theme;
        try {
            const prompt = `Generate a platformer level with the theme "${selectedTheme}" for level ${level}.`;
            const response = await window.aiAPI.complete(prompt);
            const data = JSON.parse(response);
            
            // Inicializar estados para elementos dinámicos
            gameRefs.current.platformStates.clear();
            data.platforms.forEach((p, i) => {
                if(p.type === 'disappearing') gameRefs.current.platformStates.set(i, { visible: true, timer: 0 });
                else if(p.type === 'moving') gameRefs.current.platformStates.set(i, { offset: 0, dir: 1 });
            });

            gameRefs.current.enemyStates.clear();
            data.enemies.forEach((e, i) => {
                gameRefs.current.enemyStates.set(i, { ...e, active: true, initialX: e.x, dir: 1, jumpTimer: Math.random() * 120 });
            });

            gameRefs.current.collectibleStates.clear();
            data.collectibles.forEach((c, i) => {
                gameRefs.current.collectibleStates.set(i, { active: true });
            });
            
            setLevelData(data);
            setGameState('playing');
        } catch (error) {
            console.error('Error generando el nivel, usando fallback:', error);
            // Implementar un fallback más robusto si es necesario
            setGameState('themeSelect');
        }
        setIsGenerating(false);
    }, [theme, customTheme, level]);
    
    // --- Manejo de Controles (Teclado y Táctil) ---
    const handleKey = useCallback((key, isDown) => {
        gameRefs.current.keys[key.toLowerCase()] = isDown;
    }, []);

    useEffect(() => {
        const downListener = (e) => {
            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'a', 'w', 'd'].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
            handleKey(e.key, true);
        };
        const upListener = (e) => handleKey(e.key, false);
        window.addEventListener('keydown', downListener);
        window.addEventListener('keyup', upListener);
        return () => {
            window.removeEventListener('keydown', downListener);
            window.removeEventListener('keyup', upListener);
        };
    }, [handleKey]);

    // --- Lógica Principal del Juego (Game Loop) ---
    const gameLoop = useCallback(() => {
        if (gameState !== 'playing' || !levelData) return;
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const game = gameRefs.current;
        
        // 1. Actualizar estado (lógica)
        updatePlayer(game, levelData, playSound);
        updateEnemies(game, levelData);
        updatePlatforms(game, levelData);
        updateParticles(game);
        handleCollisions(game, levelData, setLives, setScore, setGameState, playSound);
        
        // 2. Actualizar cámara
        game.camera.x += (game.player.x - game.camera.x - canvas.width / 3.5) * 0.08;
        
        // 3. Dibujar todo
        drawGame(ctx, game, levelData, canvas, lives, score);

        animationRef.current = requestAnimationFrame(gameLoop);
    }, [gameState, levelData, lives, score]);

    useEffect(() => {
        if (gameState === 'playing') {
            gameLoop();
        }
        return () => {
            if (animationRef.current) cancelAnimationFrame(animationRef.current);
        };
    }, [gameState, gameLoop]);

    // --- Funciones de Lógica Separadas ---
    const updatePlayer = (game, levelData, playSound) => {
        const { player, keys } = game;
        // Movimiento horizontal
        if (keys['arrowleft'] || keys['a']) player.vx = -MOVE_SPEED;
        else if (keys['arrowright'] || keys['d']) player.vx = MOVE_SPEED;
        else player.vx *= (player.onIce ? 0.98 : 0.8);

        // Salto
        if ((keys['arrowup'] || keys['w'] || keys[' ']) && player.grounded) {
            player.vy = JUMP_FORCE;
            player.grounded = false;
            playSound('jump', 'C5');
            createParticles(game.particles, player.x + player.width / 2, player.y + player.height, 5, '#ffffff');
        }

        // Aplicar gravedad y actualizar posición
        player.vy += GRAVITY;
        player.x += player.vx;
        player.y += player.vy;
        player.grounded = false;
        player.onIce = false;
        if (player.invincible > 0) player.invincible--;
    };

    const updateEnemies = (game, levelData) => {
        game.enemyStates.forEach((enemy, index) => {
            if (!enemy.active) return;
            switch(enemy.type) {
                case 'walker':
                    enemy.x += enemy.speed * enemy.dir;
                    if (Math.abs(enemy.x - enemy.initialX) > enemy.patrolRange) {
                        enemy.dir *= -1;
                    }
                    break;
                case 'flyer':
                    enemy.x += enemy.speed * enemy.dir;
                    enemy.y = enemy.initialY + Math.sin(game.time * 0.05) * 30;
                    if (Math.abs(enemy.x - enemy.initialX) > enemy.patrolRange) {
                        enemy.dir *= -1;
                    }
                    break;
                case 'jumper':
                    enemy.jumpTimer--;
                    if (enemy.jumpTimer <= 0) {
                        enemy.vy = -8; // Fuerza de salto del enemigo
                        enemy.jumpTimer = 120 + Math.random() * 60;
                    }
                    enemy.vy = (enemy.vy || 0) + GRAVITY * 0.5;
                    enemy.y += enemy.vy;
                    // Simple colisión con el suelo para que no caiga
                    if (enemy.y > 450) {
                        enemy.y = 450;
                        enemy.vy = 0;
                    }
                    break;
            }
        });
    };

    const updatePlatforms = (game, levelData) => {
        const { platformStates } = game;
        levelData.platforms.forEach((platform, index) => {
            const state = platformStates.get(index);
            if (!state) return;
            if (platform.type === 'moving') {
                state.offset += (platform.movementSpeed || 1) * state.dir;
                if (Math.abs(state.offset) >= (platform.movementRange || 50)) state.dir *= -1;
            }
            if (platform.type === 'disappearing') {
                if (state.timer > 0) {
                    state.timer--;
                    if (state.timer === 0) {
                        state.visible = !state.visible;
                        state.timer = state.visible ? 180 : 90; // Tiempo visible / invisible
                    }
                }
            }
        });
    };

    const handleCollisions = (game, levelData, setLives, setScore, setGameState, playSound) => {
        const { player, platformStates, enemyStates, collectibleStates, particles } = game;

        // Colisión con plataformas
        levelData.platforms.forEach((platform, index) => {
            const state = platformStates.get(index);
            if (platform.type === 'disappearing' && !state.visible) return;

            let pX = platform.x;
            let pY = platform.y;
            if (platform.type === 'moving' && state) {
                if (platform.movementDirection === 'vertical') pY += state.offset;
                else pX += state.offset;
            }

            if (player.vy >= 0 &&
                player.x + player.width > pX && player.x < pX + platform.width &&
                player.y + player.height > pY && player.y + player.height < pY + 20) {
                
                player.y = pY - player.height;
                player.vy = 0;
                player.grounded = true;
                
                if (platform.type === 'bouncy') {
                    player.vy = JUMP_FORCE * 1.6;
                    playSound('jump', 'G5');
                    createParticles(particles, player.x + player.width / 2, player.y + player.height, 10, levelData.theme.bouncyColor);
                }
                if (platform.type === 'ice') player.onIce = true;
                if (platform.type === 'disappearing' && state.timer === 0) state.timer = 30; // Inicia el temporizador al tocarla
                if (platform.type === 'exit') {
                    playSound('levelComplete', ["C4", "E4", "G4", "C5"], "0.5s");
                    setGameState('levelComplete');
                }
            }
        });

        // Colisión con enemigos
        enemyStates.forEach((enemy, index) => {
            if (!enemy.active) return;
            if (player.x < enemy.x + 20 && player.x + player.width > enemy.x &&
                player.y < enemy.y + 20 && player.y + player.height > enemy.y) {
                
                if (player.vy > 0 && (player.y + player.height) < (enemy.y + 15)) { // Stomp
                    enemy.active = false;
                    player.vy = ENEMY_BOUNCE_FORCE;
                    setScore(prev => prev + 50);
                    playSound('enemyStomp', 'C4');
                    createParticles(particles, enemy.x, enemy.y, 15, levelData.theme.enemyColor);
                } else if (player.invincible === 0) { // Hit
                    player.invincible = 60; // 1 segundo de invencibilidad
                    setLives(prev => prev - 1);
                    playSound('hit', 'C2');
                }
            }
        });

        // Colisión con coleccionables
        collectibleStates.forEach((collectible, index) => {
            const c_data = levelData.collectibles[index];
            if (collectible.active && player.x < c_data.x + 15 && player.x + player.width > c_data.x &&
                player.y < c_data.y + 15 && player.y + player.height > c_data.y) {
                collectible.active = false;
                setScore(prev => prev + c_data.value);
                playSound('collectGem', 'A5');
                createParticles(particles, c_data.x, c_data.y, 8, levelData.theme.gemColor);
            }
        });

        // Colisión con obstáculos
        levelData.obstacles.forEach(obstacle => {
            if (player.invincible === 0 && player.x < obstacle.x + obstacle.width && player.x + player.width > obstacle.x &&
                player.y + player.height > obstacle.y) {
                player.invincible = 60;
                setLives(prev => prev - 1);
                playSound('hit', 'C2');
            }
        });

        // Caída fuera del mapa
        if (player.y > 650) {
            setLives(prev => prev - 1);
            if (lives - 1 <= 0) {
                setGameState('gameOver');
            } else {
                player.x = 100; player.y = 300; player.vx = 0; player.vy = 0;
                game.camera.x = 0;
            }
        }
    };

    // --- Funciones de Dibujado ---
    const drawGame = (ctx, game, levelData, canvas, lives, score) => {
        const { theme } = levelData;
        ctx.fillStyle = theme.backgroundColor;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(-game.camera.x, 0);

        drawPlatforms(ctx, game, levelData);
        drawCollectibles(ctx, game, levelData);
        drawEnemies(ctx, game, levelData);
        drawObstacles(ctx, game, levelData);
        drawPlayer(ctx, game);
        drawParticles(ctx, game);

        ctx.restore();
        drawUI(ctx, canvas, lives, score);
    };

    const drawPlayer = (ctx, game) => {
        const { player } = game;
        ctx.save();
        // Efecto de parpadeo cuando es invencible
        if (player.invincible > 0 && Math.floor(player.invincible / 4) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        // Squish and stretch
        const stretch = 1 - Math.min(10, Math.abs(player.vy)) * 0.03;
        const squish = player.grounded ? Math.max(0.1, 1 - Math.abs(player.vx) * 0.05) : 1;
        
        ctx.translate(player.x + player.width / 2, player.y + player.height);
        ctx.scale(squish, stretch);
        
        ctx.fillStyle = levelData.theme.playerColor;
        ctx.beginPath();
        ctx.rect(-player.width/2, -player.height, player.width, player.height);
        ctx.fill();
        
        // Ojo
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(player.vx > 0.1 ? 4 : (player.vx < -0.1 ? -4 : 0), -player.height/2, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.arc(player.vx > 0.1 ? 5 : (player.vx < -0.1 ? -3 : 0), -player.height/2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    };

    const drawPlatforms = (ctx, game, levelData) => {
        const { theme } = levelData;
        levelData.platforms.forEach((platform, index) => {
            const state = game.platformStates.get(index);
            if (platform.type === 'disappearing') {
                if (!state.visible) return;
                ctx.globalAlpha = Math.max(0, state.timer / 30);
            }

            let pX = platform.x, pY = platform.y;
            if (platform.type === 'moving' && state) {
                if (platform.movementDirection === 'vertical') pY += state.offset;
                else pX += state.offset;
            }

            ctx.fillStyle = platform.type === 'bouncy' ? theme.bouncyColor :
                            platform.type === 'ice' ? theme.iceColor :
                            platform.type === 'exit' ? theme.exitColor :
                            theme.platformColor;
            ctx.fillRect(pX, pY, platform.width, platform.height);
            ctx.globalAlpha = 1;
        });
    };

    const drawEnemies = (ctx, game, levelData) => {
        const { theme } = levelData;
        game.enemyStates.forEach(enemy => {
            if (!enemy.active) return;
            ctx.fillStyle = theme.enemyColor;
            ctx.fillRect(enemy.x, enemy.y, 20, 20); // Simple rect for now
        });
    };
    
    const drawCollectibles = (ctx, game, levelData) => {
        const { theme } = levelData;
        game.collectibleStates.forEach((collectible, index) => {
            const c_data = levelData.collectibles[index];
            if (!collectible.active) return;
            ctx.fillStyle = c_data.type === 'gem' ? theme.gemColor : theme.powerupColor;
            ctx.save();
            ctx.translate(c_data.x + 7.5, c_data.y + 7.5);
            ctx.rotate(game.time * 0.05);
            ctx.fillRect(-7.5, -7.5, 15, 15);
            ctx.restore();
        });
    };
    
    const drawObstacles = (ctx, game, levelData) => {
        const { theme } = levelData;
        ctx.fillStyle = theme.spikeColor;
        levelData.obstacles.forEach(obstacle => {
            ctx.beginPath();
            ctx.moveTo(obstacle.x, obstacle.y + obstacle.height);
            ctx.lineTo(obstacle.x + obstacle.width / 2, obstacle.y);
            ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
            ctx.closePath();
            ctx.fill();
        });
    };

    const drawUI = (ctx, canvas, lives, score) => {
        ctx.fillStyle = '#fff';
        ctx.font = '24px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText(`VIDAS: ${lives}`, 20, 40);
        ctx.textAlign = 'right';
        ctx.fillText(`PUNTOS: ${score}`, canvas.width - 20, 40);
    };

    // --- Partículas ---
    const createParticles = (particles, x, y, count, color) => {
        for (let i = 0; i < count; i++) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4 - 2,
                life: 30 + Math.random() * 20,
                color
            });
        }
    };

    const updateParticles = (game) => {
        for (let i = game.particles.length - 1; i >= 0; i--) {
            const p = game.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.1; // gravity on particles
            p.life--;
            if (p.life <= 0) game.particles.splice(i, 1);
        }
    };

    const drawParticles = (ctx, game) => {
        game.particles.forEach(p => {
            ctx.globalAlpha = p.life / 50;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 3, 3);
        });
        ctx.globalAlpha = 1;
    };

    // --- Funciones de Flujo del Juego ---
    const resetForNewLevel = (newLevel) => {
        setLevel(newLevel);
        setTheme('');
        setCustomTheme('');
        setGameState('themeSelect');
        gameRefs.current.player = { x: 100, y: 300, vx: 0, vy: 0, width: PLAYER_WIDTH, height: PLAYER_HEIGHT, grounded: false, invincible: 0 };
        gameRefs.current.camera.x = 0;
        gameRefs.current.particles = [];
    };

    const restartGame = () => {
        setScore(0);
        setLives(3);
        resetForNewLevel(1);
    };

    // --- Renderizado del Componente ---
    const renderScreen = () => {
        switch (gameState) {
            case 'menu':
                return (
                    <div className="text-center space-y-8 animate-pulse">
                        <h1 className="text-5xl md:text-7xl font-pixel bg-gradient-to-r from-purple-400 via-pink-500 to-red-500 bg-clip-text text-transparent">AI PLATFORMER</h1>
                        <button onClick={() => { Tone.start(); setGameState('themeSelect'); }} className="px-10 py-5 bg-gradient-to-r from-blue-500 to-purple-600 rounded-lg font-semibold text-xl shadow-lg hover:scale-105 transition-transform">
                            COMENZAR AVENTURA
                        </button>
                    </div>
                );
            case 'themeSelect':
                const themes = [{ name: 'Cuevas de Cristal', icon: '💎', color: '#e94560' }, { name: 'Biblioteca Flotante', icon: '📚', color: '#9b59b6' }, { name: 'Dimensión Espejo', icon: '👁️', color: '#3498db' }];
                return (
                    <div className="text-center space-y-8 max-w-4xl">
                        <h2 className="text-4xl font-pixel">Elige un Tema para el Nivel {level}</h2>
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                            {themes.map((t) => (
                                <button key={t.name} onClick={() => { setTheme(t.name); generateLevel(); }} className="p-8 rounded-lg bg-slate-700 hover:bg-slate-600 transition-all hover:scale-105 group border-4" style={{ borderColor: t.color }}>
                                    <div className="text-5xl mb-2">{t.icon}</div>
                                    <span className="font-semibold text-xl">{t.name}</span>
                                </button>
                            ))}
                        </div>
                    </div>
                );
            case 'generating':
                return <div className="text-center"><span className="text-6xl animate-spin">⚙️</span><h2 className="text-4xl font-pixel mt-4">Generando Nivel...</h2></div>;
            case 'playing':
                return (
                    <div className="relative w-full h-full flex items-center justify-center">
                        <canvas ref={canvasRef} width={960} height={640} className="border-4 border-slate-600 rounded-lg shadow-2xl max-w-full max-h-[95vh] object-contain" />
                        <div className="touch-controls md:hidden">
                            <div className="flex gap-4">
                                <button id="touch-left" className="touch-btn" onTouchStart={() => handleKey('a', true)} onTouchEnd={() => handleKey('a', false)}>◄</button>
                                <button id="touch-right" className="touch-btn" onTouchStart={() => handleKey('d', true)} onTouchEnd={() => handleKey('d', false)}>►</button>
                            </div>
                            <button id="touch-jump" className="touch-btn" onTouchStart={() => handleKey(' ', true)} onTouchEnd={() => handleKey(' ', false)}>▲</button>
                        </div>
                    </div>
                );
            case 'levelComplete':
                return (
                    <div className="text-center space-y-6">
                        <span className="text-8xl">🏆</span>
                        <h2 className="text-5xl font-pixel text-yellow-300">¡Nivel Completado!</h2>
                        <button onClick={() => resetForNewLevel(level + 1)} className="px-10 py-5 bg-green-500 rounded-lg text-xl font-semibold">Siguiente Nivel</button>
                    </div>
                );
            case 'gameOver':
                return (
                    <div className="text-center space-y-6">
                        <span className="text-8xl">💀</span>
                        <h2 className="text-5xl font-pixel text-red-500">Fin del Juego</h2>
                        <div className="flex gap-4 justify-center">
                           <button onClick={() => { setLives(3); resetForNewLevel(level); }} className="px-8 py-4 bg-blue-500 rounded-lg font-semibold">Intentar de Nuevo</button>
                           <button onClick={restartGame} className="px-8 py-4 bg-gray-600 rounded-lg font-semibold">Menú Principal</button>
                        </div>
                    </div>
                );
            default:
                return <div>Cargando...</div>;
        }
    };

    return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-slate-900 text-white p-4">
            {renderScreen()}
        </div>
    );
};

ReactDOM.render(<PlatformerGame />, document.getElementById('root'));

</script>
</body>
</html>
